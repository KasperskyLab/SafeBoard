/*
Стековый калькулятор
Есть изначально пустой стековый калькулятор неограниченного размера. Он умеет выполнять следующие команды:

top При выполнении данной команды происходит печать вершины стека.
push(с одним аргументом) После выполнения данной команды её аргумент размещается на вершине стека.
add При выполнении данной команды из стека извлекаются два верхних элемента и на вершину стека кладётся их сумма.
sub При выполнении данной команды из стека извлекаются два верхних элемента и на вершину стека записывается разность первого и второго извлечённых чисел.
mul При выполнении данной команды из стека извлекаются два верхних элемента и на вершину стека кладётся их произведение.
Любая последовательность команд заканчивается командой top, результатом которой должна быть печать текущей вершины стека в выходной поток.

На вход подаётся число n (1<=n<=5000 ) – длина последовательности команд для стекового калькулятора. Далее следует n строк, каждая является описанием очередной команды.
Все аргументы команды push - целые числа, по модулю не превышающие 2^31-1.
Гарантируется, что команда top в программе одна и она является последней в последовательности команд.
Также гарантируется, что на момент выполнения очередной команды add, sub, mul в стеке будет не менее 2 чисел, размер результата на любом шаге по модулю не превысит 2^63-1.

В качестве ответа к задаче выведите результат команды top

Примеры
Вход
6
push 1
push 3
add
push -10
sub
top

Результат: -14
*/

package main

import (
  "fmt"
  "os"
  "bufio"
  "strconv"
)

func solution() (int, error) {
  var res int
  var stack []int

  file, err := os.Open("input.txt")
  if err != nil {
    return 1, err
  }
  defer file.Close()

  txt := bufio.NewScanner(file)
  for txt.Scan() {
    switch string(txt.Text()[0:1]) {
    case "p":
      convert, err := strconv.Atoi(string(txt.Text()[5:]))
      if err != nil {
        return 1, err
      }
      if len(stack) <= 1 { stack = append(stack, convert) }
      copy(stack[1:], stack)
      stack[0] = convert
    case "a":
      a := stack[0] + stack[1]
      copy(stack[1:], stack)
      stack[0] = a
    case "s":
      s := stack[0] - stack[1]
      copy(stack[1:], stack)
      stack[0] = s
    case "m":
      m := stack[0] * stack[1]
      copy(stack[1:], stack)
      stack[0] = m
    case "t":
      res = stack[0]
      break
    }
  }

  return res, nil
}

func main() {
  sol, err := solution()
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(sol)
}
